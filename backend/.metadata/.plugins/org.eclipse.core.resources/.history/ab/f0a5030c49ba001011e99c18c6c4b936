// src/main/java/com/example/crop/service/CropRequestService.java
package com.example.crop.service;

import com.example.crop.config.RabbitConfig;
import com.example.crop.dto.CreateRequestDto;
import com.example.crop.entity.*;
import com.example.crop.repository.CropRepository;
import com.example.crop.repository.CropRequestRepository;
import com.example.crop.util.JwtUtil;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;

@Service
public class CropRequestService {

    private final CropRequestRepository repo;
    private final CropRepository cropRepo;
    private final JwtUtil jwtUtil;
    private final RabbitTemplate rabbit;

    public CropRequestService(CropRequestRepository repo,
                              CropRepository cropRepo,
                              JwtUtil jwtUtil,
                              RabbitTemplate rabbit) {
        this.repo = repo;
        this.cropRepo = cropRepo;
        this.jwtUtil = jwtUtil;
        this.rabbit = rabbit;
    }

    public CropRequest sendRequest(CreateRequestDto dto, String authHeader) {
        String role = extractRole(authHeader);
        Long dealerId = extractUserId(authHeader);

        if (!"DEALER".equalsIgnoreCase(role)) {
            throw new RuntimeException("Only DEALER can send requests");
        }
        if (dto.getCropId() == null || dto.getQuantity() == null || dto.getOfferedPrice() == null) {
            throw new RuntimeException("cropId, quantity and offeredPrice are required");
        }

        Crop crop = cropRepo.findById(dto.getCropId())
                .orElseThrow(() -> new RuntimeException("Crop not found"));
        if (crop.getStatus() != CropStatus.APPROVED) {
            throw new RuntimeException("Cannot request a crop that is not APPROVED");
        }

        CropRequest req = new CropRequest();
        req.setCropId(crop.getId());
        req.setFarmerId(crop.getFarmerId());
        req.setDealerId(dealerId);
        req.setOfferedPrice(dto.getOfferedPrice());
        req.setQuantity(dto.getQuantity());
        req.setStatus(RequestStatus.PENDING);
        req.setCreatedAt(LocalDateTime.now());

        CropRequest saved = repo.save(req);

        // Optional: notify via Rabbit
        rabbit.convertAndSend(
                RabbitConfig.CROP_EXCHANGE,
                "crop.requested." + crop.getId(),
                Map.of(
                        "type", "CROP_REQUESTED",
                        "requestId", saved.getId(),
                        "cropId", crop.getId(),
                        "farmerId", crop.getFarmerId(),
                        "dealerId", dealerId,
                        "offeredPrice", saved.getOfferedPrice(),
                        "quantity", saved.getQuantity()
                )
        );

        return saved;
    }

    // Role-aware listing
    public List<CropRequest> getRequestsForUser(String authHeader) {
        String role = extractRole(authHeader);
        Long userId = extractUserId(authHeader);

        return switch (role.toUpperCase()) {
            case "DEALER" -> repo.findByDealerId(userId);
            case "FARMER" -> repo.findByFarmerId(userId);
            case "ADMIN"  -> repo.findAll();
            default       -> throw new RuntimeException("Unauthorized");
        };
    }

    // Only the target farmer can approve/reject
    public CropRequest updateRequestStatus(Long id, String newStatus, String authHeader) {
        String role = extractRole(authHeader);
        Long userId = extractUserId(authHeader);

        CropRequest req = repo.findById(id).orElseThrow(() -> new RuntimeException("Request not found"));

        if (!"ADMIN".equalsIgnoreCase(role) && !req.getFarmerId().equals(userId)) {
            throw new RuntimeException("Only the owner farmer (or admin) can update this request");
        }

        RequestStatus status = RequestStatus.valueOf(newStatus);
        req.setStatus(status);

        CropRequest saved = repo.save(req);

        // Optional: notify via Rabbit
        rabbit.convertAndSend(
                RabbitConfig.CROP_EXCHANGE,
                "crop.request." + saved.getId() + "." + status.name().toLowerCase(),
                Map.of(
                        "type", "CROP_REQUEST_STATUS",
                        "requestId", saved.getId(),
                        "status", saved.getStatus().name(),
                        "farmerId", saved.getFarmerId(),
                        "dealerId", saved.getDealerId()
                )
        );

        return saved;
    }

    private String extractRole(String authHeader) {
        if (authHeader == null || !authHeader.startsWith("Bearer ")) return "PUBLIC";
        return jwtUtil.extractRole(authHeader.substring(7));
    }

    private Long extractUserId(String authHeader) {
        if (authHeader == null || !authHeader.startsWith("Bearer ")) return null;
        return jwtUtil.extractUserId(authHeader.substring(7));
    }
}
